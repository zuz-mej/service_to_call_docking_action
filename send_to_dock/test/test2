#include <gtest/gtest.h>
#include <rclcpp/rclcpp.hpp>
#include <std_srvs/srv/set_bool.hpp>

#include "send_to_dock/send_to_dock_node.hpp"

class TestDockService: public testing::Test
{
protected:
  rclcpp::Node::SharedPtr node;

  void SetUp() override
  {
    rclcpp::init(0, nullptr);

    // Uruchamianie twojego node
    node = std::make_shared<SendToDockNode>();

    // Tworzenie klienta do serwisu 'send_robot_to_dock'
    auto client = node->create_client<std_srvs::srv::SetBool>("send_robot_to_dock");

    // Czekanie na dostępność serwisu
    ASSERT_TRUE(client->wait_for_service(std::chrono::seconds(2)));
  }

  void TearDown() override
  {
    rclcpp::shutdown();
  }
};

TEST_F(TestDockService, testNodeInteraction)
{
  // Przygotowanie wiadomości do wysłania
  auto request = std::make_shared<std_srvs::srv::SetBool::Request>();
  request->data = true;

  // Wywołanie serwisu 'send_robot_to_dock'
  auto result_future = client->async_send_request(request);

  // Pętla spin
  rclcpp::spin_until_future_complete(node, result_future);

  // Pobranie wyniku
  auto result = result_future.get();

  // Upewnienie się, że funkcja serwisowa została prawidłowo wykonana
  ASSERT_TRUE(result->success);
}


int main(int argc, char ** argv)
{
  testing::InitGoogleTest(&argc, argv);
  rclcpp::init(0, nullptr);

  auto result = RUN_ALL_TESTS();

  rclcpp::shutdown();
  return result;
}









// wersja 121231

#include <gtest/gtest.h>
#include <rclcpp/rclcpp.hpp>
#include <std_srvs/srv/set_bool.hpp>

#include "send_to_dock/send_to_dock_node.hpp"

using namespace std::chrono_literals;

class SendToDockTest : public ::testing::Test {
protected:
  static void SetUpTestCase() {
    rclcpp::init(0, nullptr);
  }

  static void TearDownTestCase() {
    rclcpp::shutdown();
  }

  void SetUp() override {
    node_ = std::make_shared<SendToDockNode>();
    exec_ = std::make_shared<rclcpp::executors::SingleThreadedExecutor>();
    exec_->add_node(node_);
    spin_thread_ = std::thread([this]() { exec_->spin(); });
  }

  void TearDown() override {
    exec_->cancel();
    spin_thread_.join();
    exec_->remove_node(node_);
  }

  std::shared_ptr<SendToDockNode> node_;
  std::shared_ptr<rclcpp::executors::SingleThreadedExecutor> exec_;
  std::thread spin_thread_;
};

TEST_F(SendToDockTest, NodeStartsAndRegistersService) {
  auto client = node_->create_client<std_srvs::srv::SetBool>("send_robot_to_dock");

  // Czekamy aż serwis się zarejestruje
  ASSERT_TRUE(client->wait_for_service(2s));
}

TEST_F(SendToDockTest, ServiceCallTriggersActionClient) {
  // UWAGA: Ten test NIE sprawdza czy goal dotarł do action servera.
  // Sprawdza tylko czy po wywołaniu serwisu zostanie wywołany callback.

  auto client = node_->create_client<std_srvs::srv::SetBool>("send_robot_to_dock");

  ASSERT_TRUE(client->wait_for_service(2s));

  auto request = std::make_shared<std_srvs::srv::SetBool::Request>();
  request->data = true;

  auto future_result = client->async_send_request(request);

  ASSERT_EQ(future_result.wait_for(5s), std::future_status::ready);
  auto response = future_result.get();

  // Nie sprawdzamy czy akcja się powiodła, tylko że callback się wykonał
  EXPECT_TRUE(response->success || !response->success); // sprawdzamy, że callback działa
}
